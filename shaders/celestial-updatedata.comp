#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#include sphereRaytracing.glsl
#include celestialDataStructs.glsl
#include celestialComputeSet.glsl
#include polar.glsl
#include proceduralValueNoise.glsl

float noise4d2(vec4 a) {
    return (noise4d(a) + noise4d((a) + 100.5)) * 0.5;
}
float fbm(vec4 a){
    return noise4d(a) * 0.5
        +noise4d(a*2.0) * 0.25
        +noise4d(a*4.0) * 0.125
        +noise4d(a*8.0) * 0.065
        +noise4d(a*16.0) * 0.032;
}
float fbm3d(vec3 a){
    return noise3d(a) * 0.5
        +noise3d(a*2.0) * 0.25
        +noise3d(a*4.0) * 0.125
        +noise3d(a*8.0) * 0.065
        +noise3d(a*16.0) * 0.032;
}
float fbm2(vec4 a){
    return fbm(a + (vec4(fbm(a + 100.0), fbm(a + 300.0), fbm(a + 600.0), 0.0) * 2.0 - 1.0));
}

float fbm3d2(vec3 a){
    return fbm3d(a + vec3(fbm3d(a + 100.0), fbm3d(a + 300.0), fbm3d(a + 600.0)) * 2.0 - 1.0);
}

vec3 getGroundColor(RenderedCelestialBody body, float sunPower, float height){
    vec3 ice = vec3(0.9);
    vec3 mids = body.sufraceMainColor;
    vec3 deserts = mix(vec3(1.0), body.sufraceMainColor, 0.3);
    sunPower *= pow(1.0 - height, 4.0);
    float icemix = 1.0 - smoothstep(0.005, 0.00505, sunPower);
    float desertmix = smoothstep(0.4, 0.41, height);
    return mix(mix(deserts, mids, desertmix) , ice, icemix);
}
vec3 getWaterColor(){
    return vec3(0.2, 0.5, 0.8);
}
void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(heightMapImage);
    vec2 UV = vec2(pixel) / vec2(resolution);
    vec3 dir = polarToXyz(UV);

    RenderedCelestialBody body = getRenderedBody(celestialBuffer.celestialBody);

    float seed = body.seed;
    float cc1 = hash(seed);
    seed += 1.0;
    float cc2 = hash(seed);
    seed += 1.0;
    float clouds =  sqrt(sqrt((1.0 - abs(dir.z)))) * fbm3d2(dir * 17.0);
    float flunctuations = step(0.01, body.terrainMaxLevel) + (1.0 - step(0.01, body.terrainMaxLevel)) * fbm3d(dir * 2.0 * vec3(1.0, 4.0 + 5.0 * hash(seed), 1.0));
    seed += 1.0;
    float radius = body.radius;
    float terrain_thickness =body.terrainMaxLevel * radius * 0.1;
    float water_level = body.fluidMaxLevel * 0.15;
    float height = pow(1.2 * fbm3d2(dir * 9.0) * fbm3d(dir * 2.0), 1.8 + 1.3 * hash(seed));
    float watermix = 1.0 - smoothstep(water_level, water_level+0.001, height);

    //RenderedCelestialBody body = getRenderedBody(celestialBuffer.celestialBody);
    imageStore(heightMapImage, pixel, vec4(height, 0.0, 0.0, 0.0));
    imageStore(baseColorImage, pixel, mix(vec4(getGroundColor(body, 1.0 - abs(dir.z), height), 1.0), vec4(getWaterColor(), 0.2), watermix));
    imageStore(cloudsImage, pixel, vec4(1.0));
}
